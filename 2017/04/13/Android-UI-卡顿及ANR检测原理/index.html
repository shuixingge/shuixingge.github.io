<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android UI 卡顿及ANR检测原理 · shuixingge</title><meta name="description" content="Android UI 卡顿及ANR检测原理 - Shuixingge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="shuixingge"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.zhihu.com" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/shuixingge" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android UI 卡顿及ANR检测原理</h1><div class="post-info">Apr 13, 2017</div><div class="post-content"><h3 id="一：背景"><a href="#一：背景" class="headerlink" title="一：背景"></a>一：背景</h3><p>众所周知，Android不允许在UI线程中做耗时的操作，否则有可能发生ANR的可能，默认情况下，在Android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。如果操作这个时长，则会产生ANR。而本文所要介绍的主要内容是检测UI线程中的耗时操作，从而能够定位一些老代码中的各种耗时的操作，作为性能优化的依据。</p>
<h3 id="二：常见方案"><a href="#二：常见方案" class="headerlink" title="二：常见方案"></a>二：常见方案</h3><ul>
<li>通过UI 线程looper</li>
<li>通过Choreographer</li>
</ul>
<h4 id="2-1-通过UI-线程looper的打印日志"><a href="#2-1-通过UI-线程looper的打印日志" class="headerlink" title="2.1 通过UI 线程looper的打印日志"></a>2.1 通过UI 线程looper的打印日志</h4><p>在github上也有许多开源库是基于该原理，比较有代表行的有<br><strong><em><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">AndroidPerformanceMonitor</a></em></strong></p>
<p><strong><em><a href="https://github.com/SalomonBrys/ANR-WatchDog" target="_blank" rel="external">ANR-WatchDog</a></em></strong></p>
<p>下面以AndroidPerformanceMonitor为例子来进行原理的介绍<br><strong><em><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="external">AndroidPerformanceMonitor</a></em></strong></p>
<p>通过如下代码可以看到，只存在一个主线程的Looper，所有通过主线程Handler发送的消息，都会发送到这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Initialize the current thread as a looper, marking it as an</div><div class="line">     * application's main looper. The main looper for your application</div><div class="line">     * is created by the Android environment, so you should never need</div><div class="line">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the application's main looper, which lives in the main thread of the application.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">return</span> sMainLooper;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>继续仔细观察Looper的源码可以发现，  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.target.dispatchMessage(msg);</div></pre></td></tr></table></figure>
<p>这句用来进行消息的分发处理，在处理前后分别会打印日志，如果我们在消息处理之前计一个时，在消息处理之后计算一个值，如果这两者的阈值，大于了我们设定的门限，那么就可以认为卡顿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">                ...</div><div class="line">     </div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">            Printer logging = me.mLogging;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">          &#125;</div><div class="line">              ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">```     </div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">但是MainLooper里面的默认打印的消息，并没有记录时间，这时，我们需要通过Looper.setMessageLogging来设置自定义的 Printer 。</div></pre></td></tr></table></figure>
<p>public void setMessageLogging(@Nullable Printer printer) {<br>        mLogging = printer;<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在BlockCanary中 定义了自定义的Printer  </div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line"></div><div class="line">class LooperMonitor implements Printer </div><div class="line"></div><div class="line">```  </div><div class="line">  </div><div class="line">   其println()方法逻辑就是消息处理之后各记录时间值，计算这两者的阈值，判断是否block。    </div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line"></div><div class="line">@Override</div><div class="line">    public void println(String x) &#123;</div><div class="line">        if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mPrintingStarted) &#123;</div><div class="line">            mStartTimestamp = System.currentTimeMillis();</div><div class="line">            mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();</div><div class="line">            mPrintingStarted = true;</div><div class="line">            startDump();</div><div class="line">        &#125; else &#123;</div><div class="line">            final long endTime = System.currentTimeMillis();</div><div class="line">            mPrintingStarted = false;</div><div class="line">            if (isBlock(endTime)) &#123;</div><div class="line">                notifyBlockEvent(endTime);</div><div class="line">            &#125;</div><div class="line">            stopDump();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>流程图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/460624-bfbfa0d0cc46dda3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flow.png"></p>
<h4 id="2-2-通过UI-线程looper循环发送消息"><a href="#2-2-通过UI-线程looper循环发送消息" class="headerlink" title="2.2  通过UI 线程looper循环发送消息"></a>2.2  通过UI 线程looper循环发送消息</h4><p>比较有代表性的作品</p>
<p><strong><em><a href="https://github.com/SalomonBrys/ANR-WatchDog" target="_blank" rel="external">ANR-WatchDog</a></em></strong></p>
<p>实现十分的简单，主要的类就是一个Thread, 通过使用主线程的Handler,不断的发送任务, 使得变量_tick的值不断的增加，然后再去做判断，_tick的值是否能得到，如果_tick的值没有变，则认为UI线程已经卡顿.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable _ticker = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            _tick = (_tick + <span class="number">1</span>) % Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        setName(<span class="string">"|ANR-WatchDog|"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lastTick;</div><div class="line">        <span class="keyword">int</span> lastIgnored = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</div><div class="line">            lastTick = _tick;</div><div class="line">            _uiHandler.post(_ticker);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                  <span class="comment">//睡眠一段时间，确保_tick的值更新后再做判断。</span></div><div class="line">                Thread.sleep(_timeoutInterval);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                _interruptionListener.onInterrupted(e);</div><div class="line">                <span class="keyword">return</span> ;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// If the main thread has not handled _ticker, it is blocked. ANR.</span></div><div class="line">            <span class="keyword">if</span> (_tick == lastTick) &#123;</div><div class="line">                <span class="keyword">if</span> (!_ignoreDebugger &amp;&amp; Debug.isDebuggerConnected()) &#123;</div><div class="line">                    <span class="keyword">if</span> (_tick != lastIgnored)</div><div class="line">                        Log.w(<span class="string">"ANRWatchdog"</span>, <span class="string">"An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))"</span>);</div><div class="line">                    lastIgnored = _tick;</div><div class="line">                    <span class="keyword">continue</span> ;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ANRError error;</div><div class="line">                <span class="keyword">if</span> (_namePrefix != <span class="keyword">null</span>)</div><div class="line">                    error = ANRError.New(_namePrefix, _logThreadsWithoutStackTrace);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    error = ANRError.NewMainOnly();</div><div class="line">                _anrListener.onAppNotResponding(error);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-通过Choreographer"><a href="#2-3-通过Choreographer" class="headerlink" title="2.3 通过Choreographer"></a>2.3 通过Choreographer</h4><p><strong><em><a href="https://github.com/wasabeef/Takt" target="_blank" rel="external">Takt</a></em></strong></p>
<p>Android系统从4.1(API 16)开始加入Choreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。其实UI显示的时候每一帧要完成的事情只有这三种。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/460624-1c0148ba5748a062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢帧"></p>
<p>Choreographer接收显示系统的时间脉冲(垂直同步信号-VSync信号)，在下一个frame渲染时控制执行这些操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> FPSFrameCallback());</div></pre></td></tr></table></figure>
<p>把你的回调添加到Choreographer之中，那么在下一个frame被渲染的时候就会回调你的callback.<br>通过判断两次回调doFrame执行的时间差，来判断是否发生ANR<br>以Takt为例。一下为其核心代码，主要代码都添加了注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> currentTimeMillis = TimeUnit.NANOSECONDS.toMillis(frameTimeNanos);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (frameStartTime &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// take the span in milliseconds</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> timeSpan = currentTimeMillis - frameStartTime;</div><div class="line">         <span class="comment">//渲染次数+1</span></div><div class="line">         framesRendered++;  </div><div class="line"> <span class="keyword">if</span> (timeSpan &gt; interval) &#123;</div><div class="line">       <span class="comment">//超过阈值，计算刷新频率</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> fps = framesRendered * <span class="number">1000</span> / (<span class="keyword">double</span>) timeSpan;</div><div class="line"></div><div class="line">        frameStartTime = currentTimeMillis;</div><div class="line">        framesRendered = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Audience audience : listeners) &#123;</div><div class="line"><span class="comment">//回调处理</span></div><div class="line">          audience.heartbeat(fps);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//第一次 frameStartTime＝0；</span></div><div class="line">      frameStartTime = currentTimeMillis;</div><div class="line">    &#125;</div><div class="line">      choreographer.postFrameCallback(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三：参考资料"><a href="#三：参考资料" class="headerlink" title="三：参考资料"></a>三：参考资料</h3><p><a href="!http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/">BlockCanary — 轻松找出Android App界面卡顿元凶</a><br><a href="https://github.com/android-notes/Cockroach/blob/master/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Cockroach</a><br><a href="http://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="external">Choreographer源码分析</a><br><a href="http://www.jianshu.com/p/30c1a5ad63a3" target="_blank" rel="external">Android应用ANR分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/25/Android混淆解析/" class="prev">上一篇</a><a href="/2017/02/07/OkHttp源码分析-一/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Shuixingge</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>